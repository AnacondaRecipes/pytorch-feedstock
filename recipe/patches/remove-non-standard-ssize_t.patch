diff --git a/torch/csrc/cuda/Module.cpp b/torch/csrc/cuda/Module.cpp
index ce828e9b21..bb7cada3e8 100644
--- a/torch/csrc/cuda/Module.cpp
+++ b/torch/csrc/cuda/Module.cpp
@@ -205,7 +205,7 @@ PyObject * THCPModule_cudaCachingAllocator_raw_alloc(PyObject *_unused, PyObject
         "(ssize_t size, intptr_t stream);");
     return nullptr;
   }
-  ssize_t size = PyLong_AsSsize_t(size_o);
+  auto size = PyLong_AsSsize_t(size_o);
   // NOLINTNEXTLINE(cppcoreguidelines-init-variables)
   cudaStream_t stream = static_cast<cudaStream_t>(PyLong_AsVoidPtr(stream_o));
   // NOLINTNEXTLINE(cppcoreguidelines-init-variables)
diff --git a/torch/csrc/jit/python/python_list.h b/torch/csrc/jit/python/python_list.h
index e43837b881..316387cf73 100644
--- a/torch/csrc/jit/python/python_list.h
+++ b/torch/csrc/jit/python/python_list.h
@@ -39,7 +39,7 @@ class ScriptList final {
  public:
   // TODO: Do these make sense?
   using size_type = size_t;
-  using diff_type = ssize_t;
+  using diff_type = ptrdiff_t;
 
   // Constructor for empty lists created during slicing, extending, etc.
   ScriptList(const TypePtr& type) : list_(AnyType::get()) {
diff --git a/torch/csrc/serialization.cpp b/torch/csrc/serialization.cpp
index 40905d773c..45392f175a 100644
--- a/torch/csrc/serialization.cpp
+++ b/torch/csrc/serialization.cpp
@@ -5,22 +5,22 @@
 #include <torch/csrc/serialization.h>
 
 template <class io>
-ssize_t doPartialRead(io fildes, void* buf, size_t nbytes);
+Py_ssize_t doPartialRead(io fildes, void* buf, size_t nbytes);
 
 template <class io>
-ssize_t doPartialWrite(io fildes, void* buf, size_t nbytes);
+Py_ssize_t doPartialWrite(io fildes, void* buf, size_t nbytes);
 
-static ssize_t doPartialPythonReadBuffered(PyObject* fildes, void* buf, size_t nbytes);
-static ssize_t doPartialPythonReadInto(PyObject* fildes, void* buf, size_t nbytes);
-static ssize_t doPartialPythonWrite(PyObject* fildes, void* buf, size_t nbytes);
+static Py_ssize_t doPartialPythonReadBuffered(PyObject* fildes, void* buf, size_t nbytes);
+static Py_ssize_t doPartialPythonReadInto(PyObject* fildes, void* buf, size_t nbytes);
+static Py_ssize_t doPartialPythonWrite(PyObject* fildes, void* buf, size_t nbytes);
 
 template <>
-ssize_t doPartialRead<int>(int fildes, void* buf, size_t nbytes) {
+Py_ssize_t doPartialRead<int>(int fildes, void* buf, size_t nbytes) {
   return read(fildes, buf, nbytes);
 }
 
 template <>
-ssize_t doPartialRead<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {
+Py_ssize_t doPartialRead<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {
   // Try to use fildes.readinto() instead of fildes.read()
   // because it is more memory efficient.
   // TODO: Stop calling PyObject_HasAttrString() in a loop on our read loop
@@ -32,12 +32,12 @@ ssize_t doPartialRead<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {
 }
 
 template <>
-ssize_t doPartialWrite<int>(int fildes, void* buf, size_t nbytes) {
+Py_ssize_t doPartialWrite<int>(int fildes, void* buf, size_t nbytes) {
   return write(fildes, buf, nbytes);
 }
 
 template <>
-ssize_t doPartialWrite<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {
+Py_ssize_t doPartialWrite<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {
   return doPartialPythonWrite(fildes, buf, nbytes);
 }
 
@@ -50,7 +50,7 @@ static inline bool isUnsupportedOperation() {
 }
 
 // Call Python fildes.read(nbytes) and copy it to buf.
-static inline ssize_t doPartialPythonReadBuffered(PyObject* fildes, void* buf, size_t raw_nbytes) {
+static inline Py_ssize_t doPartialPythonReadBuffered(PyObject* fildes, void* buf, size_t raw_nbytes) {
   // If we request a large amount of data, f.read() will internally try to
   // allocate a buffer of that size.  This is counterproductive, because
   // it's not the buffer we ultimately want to write the data into.  Read
@@ -76,7 +76,7 @@ static inline ssize_t doPartialPythonReadBuffered(PyObject* fildes, void* buf, s
 }
 
 // Either does fildes.readinto(buf) or fildes.write(buf)
-static inline ssize_t doPartialPythonIO(PyObject* fildes, void* buf, size_t nbytes, bool is_read) {
+static inline Py_ssize_t doPartialPythonIO(PyObject* fildes, void* buf, size_t nbytes, bool is_read) {
   auto rw_flag = is_read ? PyBUF_WRITE : PyBUF_READ;
   THPObjectPtr memview(PyMemoryView_FromMemory(
       reinterpret_cast<char*>(buf), nbytes, rw_flag));
@@ -100,12 +100,12 @@ static inline ssize_t doPartialPythonIO(PyObject* fildes, void* buf, size_t nbyt
 }
 
 // Call Python fildes.readinto(buf)
-static ssize_t doPartialPythonReadInto(PyObject* fildes, void* buf, size_t nbytes) {
+static Py_ssize_t doPartialPythonReadInto(PyObject* fildes, void* buf, size_t nbytes) {
   return doPartialPythonIO(fildes, buf, nbytes, /* is_read */ true);
 }
 
 // Call Python fildes.write(buf)
-static ssize_t doPartialPythonWrite(PyObject* fildes, void* buf, size_t nbytes) {
+static Py_ssize_t doPartialPythonWrite(PyObject* fildes, void* buf, size_t nbytes) {
   return doPartialPythonIO(fildes, buf, nbytes, /* is_read */ false);
 }
 
@@ -117,7 +117,7 @@ void doRead(io fildes, void* raw_buf, size_t nbytes) {
     errno = 0; // doPartialRead may not set errno
     // we read in 1GB blocks to avoid bugs on Mac OS X Lion
     // see https://github.com/pytorch/pytorch/issues/1031 for more details
-    ssize_t r = doPartialRead(fildes, buf, std::min<size_t>(nbytes, 1073741824));
+    Py_ssize_t r = doPartialRead(fildes, buf, std::min<size_t>(nbytes, 1073741824));
     if (r < 0) {
       int err = errno;
       TORCH_INTERNAL_ASSERT(err != 0, "read(): impossible! r < 0, but no errno was set");
@@ -149,7 +149,7 @@ void doWrite(io fildes, void* raw_buf, size_t nbytes) {
     errno = 0; // doPartialWrite may not set errno
     // we write in 1GB blocks to avoid bugs on Mac OS X Lion
     // see https://github.com/pytorch/pytorch/issues/1031 for more details
-    ssize_t r = doPartialWrite(fildes, buf, std::min<size_t>(nbytes, 1073741824));
+    Py_ssize_t r = doPartialWrite(fildes, buf, std::min<size_t>(nbytes, 1073741824));
     if (r < 0) {
       int err = errno;
       TORCH_INTERNAL_ASSERT(err != 0, "write(): impossible! r < 0, but no errno was set");
diff --git a/torch/csrc/utils/python_arg_parser.cpp b/torch/csrc/utils/python_arg_parser.cpp
index 3ee20c055b..4ca11b427e 100644
--- a/torch/csrc/utils/python_arg_parser.cpp
+++ b/torch/csrc/utils/python_arg_parser.cpp
@@ -293,12 +293,14 @@ auto handle_torch_function_indexing(PyObject* self, PyObject* index, PyObject* v
   }
   std::vector<py::handle> overridable_args;
   is_tensor_and_append_overloaded(self, &overridable_args);
-  Py_ssize_t size = PyTuple_GET_SIZE(index_tup.ptr());
-  for (Py_ssize_t i = 0; i < size; i++) {
-    PyObject *obj = PyTuple_GetItem(index_tup.ptr(), i);
+  auto  size = PyTuple_GET_SIZE(index_tup.ptr());
+  for (auto i : c10::irange(size)) {
+    auto *obj = PyTuple_GetItem(index_tup.ptr(), i);
     is_tensor_and_append_overloaded(obj, &overridable_args);
   }
-  if (val != nullptr) is_tensor_and_append_overloaded(val, &overridable_args);
+  if (val != nullptr) {
+    is_tensor_and_append_overloaded(val, &overridable_args);
+  }
   py::object func = PyObject_FastGetAttrString(THPVariableClass, (char *)func_name);
   py::object args = (val == nullptr) ? py::make_tuple(py::handle(self), py::handle(index)) : py::make_tuple(py::handle(self), py::handle(index), py::handle(val));
   return handle_torch_function_no_python_arg_parser(overridable_args, args.ptr(), nullptr, func_name, func.ptr(), "torch.Tensor");
@@ -825,7 +827,7 @@ std::string FunctionSignature::toString() const {
 }
 
 [[noreturn]]
-static void extra_args(const FunctionSignature& signature, ssize_t nargs) {
+static void extra_args(const FunctionSignature& signature, Py_ssize_t nargs) {
   const long max_pos_args = signature.max_pos_args;
   const long min_args = signature.min_args;
   const long nargs_ = nargs;
@@ -862,8 +864,8 @@ static void missing_args(const FunctionSignature& signature, int idx) {
       ss.str().c_str());
 }
 
-static ssize_t find_param(FunctionSignature& signature, PyObject* name) {
-  ssize_t i = 0;
+static Py_ssize_t find_param(FunctionSignature& signature, PyObject* name) {
+  Py_ssize_t i = 0;
   for (auto& param : signature.params) {
     int cmp = PyObject_RichCompareBool(name, param.python_name, Py_EQ);
     if (cmp < 0) {
@@ -877,10 +879,10 @@ static ssize_t find_param(FunctionSignature& signature, PyObject* name) {
 }
 
 [[noreturn]]
-static void extra_kwargs(FunctionSignature& signature, PyObject* kwargs, ssize_t num_pos_args) {
-  // NOLINTNEXTLINE(cppcoreguidelines-init-variables)
-  PyObject *key, *value;
-  ssize_t pos = 0;
+static void extra_kwargs(FunctionSignature& signature, PyObject* kwargs, Py_ssize_t num_pos_args) {
+  PyObject *key = nullptr;
+  PyObject *value  = nullptr;
+  Py_ssize_t pos = 0;
 
   while (PyDict_Next(kwargs, &pos, &key, &value)) {
     if (!THPUtils_checkString(key)) {
@@ -906,8 +908,8 @@ static void extra_kwargs(FunctionSignature& signature, PyObject* kwargs, ssize_t
 bool FunctionSignature::parse(PyObject* self, PyObject* args, PyObject* kwargs, PyObject* dst[],  // NOLINT
                               bool raise_exception) {
   auto nargs = args ? PyTuple_GET_SIZE(args) : 0;
-  ssize_t remaining_kwargs = kwargs ? PyDict_Size(kwargs) : 0;
-  ssize_t arg_pos = 0;
+  auto remaining_kwargs = kwargs ? PyDict_Size(kwargs) : 0;
+  Py_ssize_t arg_pos = 0;
   bool allow_varargs_intlist = false;
 
   // if there is a single positional IntArrayRef argument, i.e. expand(..), view(...),
@@ -1073,8 +1075,8 @@ PythonArgs PythonArgParser::raw_parse(PyObject* self, PyObject* args, PyObject*
 void PythonArgParser::print_error(PyObject* self, PyObject* args, PyObject* kwargs, PyObject* parsed_args[]) {  // NOLINT
   // NOLINTNEXTLINE(clang-analyzer-core.NullDereference)
   auto num_args = PyTuple_GET_SIZE(args) + (kwargs ? PyDict_Size(kwargs) : 0);
-  std::vector<int> plausible_idxs;
-  ssize_t i = 0;
+  std::vector<unsigned> plausible_idxs;
+  unsigned i = 0;
   for (auto& signature : signatures_) {
     if (num_args >= signature.min_args && num_args <= signature.max_args && !signature.hidden) {
       plausible_idxs.push_back(i);
diff --git a/torch/csrc/utils/python_arg_parser.h b/torch/csrc/utils/python_arg_parser.h
index 6a05807e5a..1e2d20abef 100644
--- a/torch/csrc/utils/python_arg_parser.h
+++ b/torch/csrc/utils/python_arg_parser.h
@@ -120,7 +120,7 @@ private:
 
   std::vector<FunctionSignature> signatures_;
   std::string function_name;
-  ssize_t max_args;
+  size_t max_args;
   bool traceable;
 };
 
@@ -135,9 +135,9 @@ struct PYBIND11_EXPORT FunctionSignature {
   std::string name;
   std::vector<FunctionParameter> params;
   std::vector<py::handle> overloaded_args;
-  ssize_t min_args;
-  ssize_t max_args;
-  ssize_t max_pos_args;
+  size_t min_args;
+  size_t max_args;
+  size_t max_pos_args;
   int index;
   bool hidden;
   bool deprecated;
