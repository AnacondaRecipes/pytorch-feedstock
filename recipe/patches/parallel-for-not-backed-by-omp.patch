From 2350f7f9f8f0434fb83e20d0d7026ed654900a70 Mon Sep 17 00:00:00 2001
From: Nikita Shulga <nikita.shulga@gmail.com>
Date: Sat, 25 Sep 2021 07:34:47 -0700
Subject: [PATCH] MaxUnpooling: parallel_for not always backed by OMP

Use atomic optional instead of omp critical pragma inside max_unpooling
kernels

Using any OpenMP pragma in `at::parallel_for` body is wrong, as it can
be implemented using native treading algorithms such as ptrheads or
openmp

`c10::optional` sounds like a much better approach to pair of
`has_error` and `error_index` variables

It also fixes https://github.com/pytorch/pytorch/issues/65578
---
 aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp | 58 +++++++-------------
 1 file changed, 20 insertions(+), 38 deletions(-)

diff --git a/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp b/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
index 5a7b03128766..2fe4b2f2e371 100644
--- a/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
@@ -5,6 +5,8 @@
 #include <ATen/native/Pool.h>
 #include <ATen/native/cpu/utils.h>
 
+#include <c10/util/Optional.h>
+
 namespace at { namespace native {
 
 namespace {
@@ -50,8 +52,7 @@ void cpu_max_unpool(
   int64_t input_image_size = numel / channels;
   int64_t output_image_size = output.numel() / channels;
 
-  bool has_error = false;
-  int64_t error_index = 0;
+  std::atomic<c10::optional<int64_t>> optional_error_index;
 
   // parallel on dim N, C, D, H, W: [channels, input_image_size]
   at::parallel_for(0, numel, 0, [&](int64_t begin, int64_t end) {
@@ -64,11 +65,7 @@ void cpu_max_unpool(
 
       int64_t maxp = indices_data[i];
       if (maxp < 0 || maxp >= output_image_size) {
-        #pragma omp critical
-        {
-          has_error = true;
-          error_index = maxp;
-        }
+        optional_error_index = maxp;
       } else {
         output_ptr[maxp] = input_data[i];
       }
@@ -78,14 +75,14 @@ void cpu_max_unpool(
     }
   });
 
-  if (has_error) {
+  if (auto error_index = optional_error_index.load()) {
     if (is_3d) {
-      AT_ERROR("Found an invalid max index: ", error_index,
+      AT_ERROR("Found an invalid max index: ", error_index.value(),
           " (output volumes are of size ", output_depth,
           "x", output_height, "x", output_width);
       (void)error_index;
     } else {
-      AT_ERROR("Found an invalid max index: ", error_index,
+      AT_ERROR("Found an invalid max index: ", error_index.value(),
           " (output volumes are of size ", output_height,
           "x", output_width);
       (void)error_index;
@@ -120,8 +117,7 @@ void cpu_max_unpool_channels_last(
   int64_t input_image_size = input_height * input_width;
   int64_t output_image_size = output_height * output_width;
 
-  bool has_error = false;
-  int64_t error_index = 0;
+  std::atomic<c10::optional<int64_t>> optional_error_index;
 
   // parallel on dim N, H, W
   at::parallel_for(0, nbatch * input_image_size, 0, [&](int64_t begin, int64_t end) {
@@ -138,11 +134,7 @@ void cpu_max_unpool_channels_last(
       for (int64_t c = 0; c < channels; c++) {
         int64_t maxp = indices_ptr[c];
         if (maxp < 0 || maxp >= output_image_size) {
-          #pragma omp critical
-          {
-            has_error = true;
-            error_index = maxp;
-          }
+          optional_error_index = maxp;
         } else {
           output_ptr[maxp * channels + c] = input_ptr[c];
         }
@@ -153,8 +145,8 @@ void cpu_max_unpool_channels_last(
     }
   });
 
-  if (has_error) {
-    AT_ERROR("Found an invalid max index: ", error_index,
+  if (auto error_index = optional_error_index.load()) {
+    AT_ERROR("Found an invalid max index: ", error_index.value(),
         " (output volumes are of size ", output_height,
         "x", output_width);
     (void)error_index;
@@ -198,8 +190,7 @@ void cpu_max_unpool_backward(
   int64_t input_image_size = numel / channels;
   int64_t output_image_size = grad_output.numel() / channels;
 
-  bool has_error = false;
-  int64_t error_index = 0;
+  std::atomic<c10::optional<int64_t>> optional_error_index;
 
   // parallel on dim N, C, D, H, W
   at::parallel_for(0, numel, 0, [&](int64_t begin, int64_t end) {
@@ -212,11 +203,7 @@ void cpu_max_unpool_backward(
 
       int64_t maxp = indices_data[i];
       if (maxp < 0 || maxp >= output_image_size) {
-        #pragma omp critical
-        {
-          has_error = true;
-          error_index = maxp;
-        }
+          optional_error_index = maxp;
       } else {
         grad_input_data[i] = grad_output_ptr[maxp];
       }
@@ -226,15 +213,15 @@ void cpu_max_unpool_backward(
     }
   });
 
-  if (has_error) {
+  if (auto error_index = optional_error_index.load()) {
     if (is_3d) {
-      AT_ERROR("invalid max index ", error_index,
+      AT_ERROR("invalid max index ", error_index.value(),
           ", odepth= ", output_depth,
           ", owidth= ", output_width,
           ", oheight= ", output_height);
       (void)error_index;
     } else {
-      AT_ERROR("invalid max index ", error_index,
+      AT_ERROR("invalid max index ", error_index.value(),
           ", owidth= ", output_width,
           ", oheight= ", output_height);
       (void)error_index;
@@ -269,8 +256,7 @@ void cpu_max_unpool_backward_channels_last(
   int64_t input_image_size = input_height * input_width;
   int64_t output_image_size = output_height * output_width;
 
-  bool has_error = false;
-  int64_t error_index = 0;
+  std::atomic<c10::optional<int64_t>> optional_error_index;
 
   // parallel on dim N, H, W
   at::parallel_for(0, nbatch * input_image_size, 0, [&](int64_t begin, int64_t end) {
@@ -286,11 +272,7 @@ void cpu_max_unpool_backward_channels_last(
       for (int64_t c = 0; c < channels; c++) {
         int64_t maxp = indices_ptr[c];
         if (maxp < 0 || maxp >= output_image_size) {
-          #pragma omp critical
-          {
-            has_error = true;
-            error_index = maxp;
-          }
+          optional_error_index = maxp;
         } else {
           grad_input_ptr[c] = grad_output_ptr[maxp * channels + c];
         }
@@ -301,8 +283,8 @@ void cpu_max_unpool_backward_channels_last(
     }
   });
 
-  if (has_error) {
-    AT_ERROR("invalid max index ", error_index,
+  if (auto error_index = optional_error_index.load()) {
+    AT_ERROR("invalid max index ", error_index.value(),
         ", owidth= ", output_width,
         ", oheight= ", output_height);
     (void)error_index;
